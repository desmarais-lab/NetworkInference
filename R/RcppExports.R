# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Exponential density
dexp_ <- function(x, lambda = 1) {
    .Call('NetworkInference_dexp_', PACKAGE = 'NetworkInference', x, lambda)
}

#' Calculate the edge weight between two nodes
edge_weight_ <- function(event_time_i, event_time_j, lambda, beta = 0.5, epsilon = 0.00000000001, tied = FALSE, model = 1L) {
    .Call('NetworkInference_edge_weight_', PACKAGE = 'NetworkInference', event_time_i, event_time_j, lambda, beta, epsilon, tied, model)
}

#' Run the netinf algorithm on a set of nodes and cascades
#' 
#' @param node_ids An integer vector of integer node ids.
#' @param cascade_nodes A list of integer vectors containing the node ids of
#'     the cascade in order of infection.
#' @param  cascade_times A list of numeric vectors each containing infection 
#'     times for the corresponding nodes in \code{cascade_ids}.
#' @param model integer indicating the choice of model: 0: exponential, 
#'     1: power law, 2: rayleigh.
#' @param alpha Numeric, alpha for transmission model.
#' @param n_iter Numeric, number of iterations for optimization.
#' @param verbose boolean, should additional information be printed.
#' @param edge_info boolean, should addditional edge information be returned
#' 
#' @return List containing one vector per edge.
netinf_ <- function(node_ids, cascade_nodes, cascade_times, model = 0L, alpha = 1.0, n_iter = 5L, verbose = TRUE, edge_info = TRUE) {
    .Call('NetworkInference_netinf_', PACKAGE = 'NetworkInference', node_ids, cascade_nodes, cascade_times, model, alpha, n_iter, verbose, edge_info)
}

#' Calculate the optimal spanning tree for a cascade
optimal_spanning_tree_ <- function(this_cascade_ids, this_cascade_times, lambda, beta, epsilon) {
    .Call('NetworkInference_optimal_spanning_tree_', PACKAGE = 'NetworkInference', this_cascade_ids, this_cascade_times, lambda, beta, epsilon)
}

